== Writing drogue device drivers

Drogue-device contains device drivers for different boards and sensors.
Drivers follow a common set of patterns that makes it easier to write
new drivers. Device drivers can be written in different ways, but the
common approach is to implement one or more of the following:

* A trait that defines the API that a class of drivers implement. This may already exist, either in drogue-device or elsewhere. We encourage re-using existing traits where it makes sense. The traits are placed in `device/src/traits`.
* A driver that implements an API, either using a HAL or hardware directly. Drivers are located in `device/src/drivers/`.
* An actor implementation for the driver. This is useful for peripherals that require shared access by multiple parts of the system, as the actor will ensure its only serving one user at a time.  Actors are locate in `device/src/actors`.

Which of the above you decide to implement depends on the driver. A Led may not need an actor, because it is usually operated only by a single component, whereas it makes sense for a network stack/driver that is used by multiple components.

Note that Actors do carry with them an overhead of extra code to spawn its task, holding message references etc. Therefore, it may make sense using a layered approach: A driver that can be used for the cases where you don't need the shared access, and an Actor for the cases where you need shared access.

== Writing an async trait

Drogue-device prefers async APIs, as it provides the most benefit in an async environment like drogue-device.

Unfortunately, the support in Rust for writing async traits is limited, but it is possible using features from Rust nightly.

[source, rust]
----
#![feature(generic_associated_types)]

// A few dummy types
pub struct ApiRequest;
pub struct ApiError;

pub trait MyTrait {
    type SomethingFuture<'m>: Future<Output = Result<(), ApiError>> where Self: 'm;

    fn do_something<'m>(&'m mut self, request: ApiRequest) -> Self::SomethingFuture<'m>;
}
----

With the above, an implementor of the API will be able to write async code with some boilerplate, and application code can rely on the trait.

== Writing an async driver

A driver is an implementation of the API that embedded applications use. With the API defined in the previous section, lets take a look at what a driver would look like:

[source, rust]
----
#![feature(type_alias_impl_trait)]
#![feature(generic_associated_types)]

use api::{ApiError, ApiRequest, MyTrait};
    
pub struct MyImpl {}

impl MyTrait for MyImpl {
    type SomethingFuture<'m> = impl Future<Output = Result<(), ApiError>> + 'm;

    fn do_something<'m>(&'m mut self, request: ApiRequest) -> Self::SomethingFuture<'m> {
       async move {
             // Driver code
             Err(ApiError)
       }
    }
}
----

At the expense of needing to define the associated type and a somewhat awkward return value, the driver
can write blocks of async code to implement the trait.

==  Writing an Actor

// TODO!